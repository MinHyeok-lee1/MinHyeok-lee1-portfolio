import Image from "next/image";

# 소프트웨어 공학용어

## OOP(Object Oriented Programming)

OOP란?

1. 객체 지향 프로그래밍(OOP)은 "객체"라는 개념을 기반으로 하는 프로그래밍 패러다임이다.
2. 객체는 데이터(속성 또는 프로퍼티로 알려짐)와 그 데이터에 작용하는 코드(메서드로 알려짐)를 포함할 수 있다.

### 주요 특징

1. 캡슐화
   - 데이터를 해당 데이터를 조작하는 메서드와 함께 하나의 단위(객체)로 묶는 것이다.
   - 이를 통해 객체의 내부 상태를 외부의 불필요한 간섭으로부터 보호할 수 있다.
2. 상속
   - 하나의 클래스가 다른 클래스의 속성과 메서드를 상속받는 메커니즘이다.
   - 이를 통해 코드의 재사용성과 계층 구조를 수립할 수 있다.
3. 다형성(폴리모피즘)
   - 동일한 인터페이스를 통해 서로 다른 데이터 타입을 처리할 수 있는 능력이다.
   - 이를 통해 객체를 실제 클래스가 아닌 부모 클래스의 인스턴스로 취급할 수 있다.
4. 추상화
   - 복잡한 구현 세부 사항을 숨기고 객체의 필수 기능만을 노출하는 것이다.
   - 이를 통해 객체와의 상호작용이 간단해진다.

OOP는 Java, C++, Python과 같은 언어에서 자주 사용되며, 여러 객체가 상호작용하는 복잡한 시스템을 모델링하는 데 특히 효과적이다.

## FP(Functional Programming)

FP(Functional Programming)란?

1. 함수형 프로그래밍(FP)은 계산을 수학적 함수의 평가로 간주한다.
2. 상태 변경과 가변 데이터를 피하는 패러다임이다.

### 주요 특징

1. 일급 함수
   - 함수가 일급 시민으로 취급되어 다른 함수에 인수로 전달되거나 반환값으로 사용될 수 있으며, 변수에 할당될 수도 있다.
2. 순수 함수
   - 출력 값이 입력 값에만 의존하고 외부 상태를 변경하지 않는 함수이다.
   - 동일한 입력 값에 대해 항상 동일한 출력 값을 반환한다.
3. 불변성
   - 데이터가 한 번 생성되면 변경되지 않는 성질을 가진다.
   - 이는 상태 변화로 인한 부작용을 줄이는 데 도움을 준다.
4. 고차 함수
   - 함수를 인수로 받거나 함수를 반환하는 함수다.
   - 이러한 함수는 프로그램의 동작을 더욱 유연하고 모듈화할 수 있게 해준다.

## FRP(Functional Reactive Programming)

FRP란?

1. 함수형 반응형 프로그래밍(FRP)은 시간에 따라 변하는 값(시간 가변적 값)과 이벤트를 함수형 프로그래밍의 개념을 사용해 다루는 패러다임이다.
2. 주로 비동기 데이터 흐름을 처리하는 데 사용된다.

### 주요 특징

1. 시간 가변적 값
   - 시간에 따라 변하는 값으로, 이러한 값의 변화에 반응할 수 있는 시스템을 만든다.
2. 이벤트 스트림
   - 일련의 이벤트가 시간의 흐름에 따라 발생하는 스트림이다.
   - FRP는 이러한 이벤트 스트림을 조합하고 변환할 수 있다.
3. 선언적 프로그래밍
   - 시스템의 행동을 선언적으로 표현한다.
   - 즉, 어떻게 동작하는지에 대한 절차를 명시하기보다는 무엇을 하고 싶은지 명확하게 기술한다.

FRP는 주로 사용자 인터페이스, 애니메이션, 게임 개발에서 비동기 데이터를 관리하는 데 사용된다.

## 동적 계획법(Dynamic Programming, DP), 분할 정복(Divide and Conquer)의 정의와 차이점

### 분할 정복(Divide and Conquer)

- 정의: 상위 문제를 나눌 수 없을 때까지 분할하여 각 하위 문제를 풀고 다시 합병하여 상위 문제의 답을 얻는 방식의 알고리즘이다.

#### 특징

- 하향식 접근법: 상위 문제의 답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식. 즉, 상위 문제의 답을 구하기 위해 이전에 수행해야 하는 절차를 수행하는 방식이다.(재귀함수로 구현)
- 문제를 쪼갤 때, 부분 문제의 중복이 없다.

예: 병합 정렬, 퀵 정렬 등

### 동적 계획법(Dynamic Programming, DP)

- 정의: 하나의 큰 문제를 해결하기 위해, 큰 문제를 작은 문제들로 나누어 부분적으로 해결한 후 그로부터 파생된 값인 해를 이용하여 최종적으로 전체 문제를 해결하는 방식의 알고리즘이다.

#### 특징

- 가장 최하위 문제의 해답을 구한 후, 이를 이용하여 상위 문제를 풀어나가는 방식인 상향식 접근법이다.
- 큰 문제를 작게 쪼개어 문제를 해결할 때 중복되는 부분이 발생한다면 사용한다.
- 동일한 연산에 대해서는 1번의 연산을 수행하여 저장하여 계산의 중복을 방지한다.
- 중복을 방지하여 전체적인 수행 및 연산시간을 절약하여 실행 속도를 빠르게 한다.
- 메모이제이션(memoization)을 사용한다.
- 메모이제이션, 타뷸레이션을 사용하지않은 경우의 시간 복잡도: O(n\*n)
- 메모이제이션을 사용할 경우 시간 복잡도: O(n)
- 타뷸레이션을 사용할 경우 시간 복잡도: O(1)

예: 피보나치 수열, 팩토리얼 등

### 동적 계획법과 분할 정복의 공통점과 차이점

- 공통점: 큰 문제를 작게 쪼개어 가장 작은 단위로 분할하여 문제를 해결한다.
- 차이점
  - 동적 계획법: 부분 문제에 중복이 발생할 경우 상위문제 해결 시 재활용하는 memoization을 사용한다.
  - 분할 정복: 부분 문제에 중복이 존재하지 않아 memoization을 사용하지 않는다.
  - 부분 문제에 중복이 발생할 경우 동적 계획법을 사용하고 발생하지 않는 경우 분할 정복을 사용한다.

## 타뷸레이션(Tabulation), 메모이제이션(Memoization)의 정의와 차이점

### 타뷸레이션(Tabulation)이란?

- 동일한 계산을 반복해야 할 경우 한 번 계산한 결과를 메모리에 저장해 두었다가 재사용하여 중복 계산을 방지할 수 있게 하는 기법이다.
- 중복 계산을 방지하여 전체 실행 속도를 빠르게 한다.
- 앞으로 계산할 모든 값에 대해 저장하여 초기화 오버헤드가 크다.
- 초기화 이후에 계산해둔 값을 사용할 때 더 이상의 계산이 필요하지 않다.
- Table + ulation으로 테이블에 미리 값을 적어놓는다고 생각하자.

### 메모이제이션(memoization)이란?

- 동적 프로그래밍(DP: Dynamic Programing)의 핵심이 되는 기술이다.
- 동일한 계산을 반복해야 할 경우 한 번 계산한 결과를 메모리에 저장해 두었다가 재사용하여 중복 계산을 방지할 수 있게 하는 기법이다.
- 중복 계산을 방지하여 전체 실행 속도를 빠르게 한다.
- 이론적인 용어라 코딩 테스트, 알고리즘에서만 사용하는 용어이고 실제 현장에서는 캐싱(caching)이라는 단어를 더 많이 사용한다.
- 예:
  - 피보나치 수열: f(n-1), f(n-2)의 값을 메모이제이션하여 f(n)을 계산한다.
  - 팩토리얼을: f(n-1), f(n-2) .... 1의 값을 메모이제이션하여 f(n)을 계산한다.

### 타뷸레이션과 메모이제이션의 차이점

1. 메모이제이션과 비슷하지만, 값을 미리 계산해둔다는 차이점이 있다.
2. 메모이제이션 결과가 필요해질 때 계산한다.(Lazy-Evaluation)
   - 필요한 값의 요청이 들어올 때 이전에 계산해둔 값이 있다면 그 값을 사용하고 없다면 새로 계산한다.
   - memoization을 활용하여 값을 계산할 경우 시간 복잡도는 O(n)이다.
3. 타뷸레이션은 필요하지 않은 값도 미리 계산해둔다(Eager-Evaluation)는 차이가 있다.
   - 이전에 계산해둔 값이 있다면 그 값을 사용하고 없다면 새로 계산하는 방식으로 초기화할 때 범위에 해당하는 모든 값을 계산한다.
   - 초기화 오버헤드가 있지만 일단 계산해둔 값은 시간복잡도가 상수 시간(O(1))이 된다.

## 재귀(recursion) 및 재귀함수(recursive function), 팩토리얼을 구하는 함수 예제코드

1. 재귀
   - 자기자신을 호출한다는 말로 자기자신을 반복해서 돌아간다라는 의미를 가지고 있다.
2. 재귀함수
   - 재귀를 하는 함수로 정의 단계에서 자신을 재참조하는 함수를 뜻한다.
3. 재귀함수의 예시로 팩토리얼을 구하는 예제코드이다.

```js
const factorial = function (number) {
  if (number > 0) {
    return number * factorial(number - 1);
  } else {
    return 1;
  }
};

console.log(factorial(10));
```

- factorial 함수는 재귀함수로 factorial함수에서 factorial 함수를 또 호출한다. (자기 자신을 호출하는 것이다)
- 인자만 함수 내부에서 n에서 n-1로 바뀌게 된다.
- factorial(3)을 호출하면 내부적으로는 3 \* factorial(2)가 호출된다.
- factorial(2)는 2 _ factorial(1)을 호출하고 factorial(1)은 1 _ factorial(0)을 호출한다.
- factorial(0)==1이기때문에 최종적으로 결과는 3 _ 2 _ 1 \* 1 = 6이 된다.
- 위 3~5의 과정과 같이 factorial(n)의 값을 재귀적으로 계산하여 반환한다.

4. 결론
   1. 재귀적으로 푸는 것은 분할 정복 알고리즘(Divide and Conquer Algorithm) 중의 하나이다.
      - 어떤 문제를 한 번에 풀기 힘들 때, 작은 조각으로 쪼개어 푸는 것을 분할 정복 알고리즘라고 한다.
   2. 재귀를 사용하는 것은 컴퓨터에게는 많은 부담을 주지만, 개발자의 가독성을 높혀준다.
   3. 반복문에 비해 메모리를 많이 차지하기 때문에 성능을 중시한다면 재귀를 쓰지 않는 게 좋다.
   4. 재귀는 분할정복 알고리즘, DP 등에서 사용하여 DP를 사용할 때 재귀의 반환값이 보통 메모이제이션된다.

## 에라토스테네스의 체

에라토스테네스의 체란?

1. 수학에서 에라토스테네스의 체는 고대 그리스에서 에라토스테네스가 발견한 소수를 찾는 방법이다.
2. 소수를 찾는 알고리즘 중에 하나로 2부터 찾고자하는 숫자의 범위 n의 값이 크면 클수록 효과적이다.
3. 알고리즘은 아래 사진과 같다.

<Image
  src="/eratos.gif"
  alt="에라토스테네스의 체"
  unoptimized={true}
  width={445}
  height={445}
/>

- 알고리즘
  1. 2부터 소수를 구하고자 하는 모든 수를 나열한다. 그림에서 회색 사각형으로 다른 수들이 여기에 해당한다.
  2. 2는 소수이므로 오른쪽 Prime numbers에 2를 써준다.
  3. 2를 제외한 모든 2의 배수를 지운다.
  4. 3은 소수이므로 오른쪽 Prime numbers에 3을 써준다.
  5. 3을 제외한 모든 3의 배수를 지운다.
  6. 5는 소수이므로 오른쪽 Prime numbers에 5를 써준다.
  7. 5를 제외한 모든 5의 배수를 지운다.
  8. 7은 소수이므로 오른쪽 Prime numbers에 7을 써준다.
  9. 7을 제외한 모든 7의 배수를 지운다.
  10. 위 과정을 구하고자하는 i를 2부터 i\*i가 n보다 작거나 같을때 까지만 수행해주면 된다.

예제코드

```js
let primeNumber = [];
primeNumber[0] = false;
primeNumber[1] = false;

const n = 120;
for (let i = 2; i <= n; i++) primeNumber[i] = true;

for (let i = 2; i * i <= n; i++) {
  if (primeNumber[i]) {
    for (let j = i * i; j <= n; j += i) {
      primeNumber[j] = false;
    }
  }
}

for (let i = 1; i <= n; i++) if (primeNumber[i]) console.log(i);
```

결과값으로 위 사진과 같이 소수들이 출력되는 것을 확인할 수 있다.

- outer 반복문에서 i\*i까지만 확인하는 이유는 아래와 같다.

### 에라토스테네스의 체에서 소수 판정 시 제곱근 까지만 확인하면 되는 이유

n이하의 모든 소수를 구하려고할 때 효율적으로 구하기 위해 n의 제곱근까지만 확인한다.

아래 예시를 보자.

1. n이하의 모든 소수를 구하고자할 때 n은 x와 y에 대해 n = x\*y이다. (x와 y는 자연수이다.)
2. n = m\*m이다. (m이 n의 제곱근이다.)
3. n = x*y이고 n = m*m이므로 x*y = m*m이다.

이 상태에서 x와 y가 자연수인 경우는 아래 3가지 경우이다.

1. x = y = m일 경우
2. x < m, y > m일 경우
3. x > m, y < m일 경우

결론

1. x와 y가 자연수가 되려면 위 세가지 경우 중 하나의 경우여야 한다.
2. x와 y의 최소값은 m보다 작거나 같아야한다. `(min(x,y) <= m)`
3. n의 모든 약수에 해당하는 자연수 x와 y는 x=y=m을 제외하고는 x와 y중 하나는 무조건 m보다 작아야 한다.
4. 결과적으로 m까지만 조사한다면 n이 소수인지 확인할 수 있다.

추가적으로 n보다 작은 모든 수에 대해 n의 제곱근으로 소수 판정 또한 가능하다.

1. n보다 작은 수 중에 가장 큰 수인 n-1에 대하여 n의 제곱근이 n-1의 제곱근보다 무조건 크다.
2. 위와 같이 n보다 작은 모든 수의 제곱근은 n의 제곱근보다 작으므로 n뿐만아니라 n보다 작은 모든 값에 대해 소수 판정이 가능하다.
