# 데이터베이스 용어

## NDV(Number of Distinct Value)

NDV는 특정 컬럼에 unique한 값이 얼마나 있는지 나타낸다.  
중복되는 값이 존재하지 않는 primary key와 같이 unique한 속성을 지닌 컬럼의 경우는 테이블의 행수와 개수가 일치한다.

## 카디널리티(Cardinality)

카디널리티(Cardinality)는 특정 데이터 집합의 유니크(Unique)한 값의 개수이다.  
NDV와 값이 같다.

주민등록번호와 이름이라는 컬럼이 있는 테이블이 있다고 가정해보자.  
주민등록번호는 값이 중복되지 않는 유일한(Unique) 값이다.  
이름은 값이 중복되기도 하는 값이다.  
그러므로 주민등록번호의 카디널리티가 이름의 카디널리티보다 높다.

## 선택도(Selectivity)

선택도 = (카디널리티 / 총 레코드 수) \* 100  
선택도는 데이터 집합에서 특정 값을 얼마나 잘 골라낼 수 있는지에 대한 지표이다.  
전체 레코드 중에서 조건절에 의해 선택될 것으로 예상되는 레코드의 비율(%)이다.  
선택도가 1이라는 뜻은 모든 값이 유니크하다는 의미다.

선택도는 데이터베이스에서 인덱스를 생성할 컬럼을 고를 때 자주 사용한다.  
선택도가 높은 컬럼에 인덱스를 걸면 인덱스가 특정 레코드를 잘 골라내어 인덱스 효율이 높아진다.  
반대로 선택도가 낮은 컬럼에 인덱스를 걸게 되면 인덱스 효율이 낮아지고 결국 풀 테이블 스캔으로 플랜이 풀리게 될 수 있다.

- Selectivity = ( 조회하는 row / 테이블의 총 row ) \* 100: 위에서 표현하는 선택도에서는 선택도가 낮을 수록 인덱스 효율이 좋다. (5 ~ 10%가 적당하다)
- 밀도(Density): 밀도 = 1 / NDV

## Clustered Index

인덱스 저장 방식에는 Clustered Index과 Non-Clustered Index가 있다.

1. 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식이다.
2. 실제 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있다.
3. 데이터 삽입, 삭제 발생 시 순서를 유지하기 위해 데이터를 재정렬 해야한다.
4. 한 개의 릴레이션에 하나의 인덱스만 생성 가능하다.

## Non-Clustered Index

1. 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식이다.
2. 데이터를 검색하기 위해서 먼저 인덱스를 검색하여 실제 데이터의 위치를 확인해야하므로 클러스터드 인덱스에 비해 검색 속도가 떨어진다.
3. 한 개의 릴레이션에 여러개의 인덱스를 만들 수 있다.

## ACID란?

- 데이터베이스 트랜잭션들이 안정적으로 수행된다는 것을 보장하기 위한 성질을 카리키는 약어이다.

1. 원자성(Atomicity)
   - 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장한다.
   - 중간 단계까지 실행되고 실패하는 일이 없도록 하는것이다.
2. 일관성(Consistency)
   - 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지한다.
3. 고립성(Isolation)
   - 트랜잭션 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장한다.
   - 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 보거나 참조할 수 없다.
   - 트랜잭션 실행내역은 연속적이어야한다.
4. 지속성(Durability)
   - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.
   - 시스템 문제, DB일관성 체크 등을 하더라도 유지되어야 한다.

## 트랜잭션이란?

데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 수행되어야할 일련의 연산들을 의미한다.

즉, 아래의 SQL문을 이용해서 DB에 접근하는 것을 의미이다.  
`INSERT SELECT UPDATE DELETE` (CRUD)  
하지만 작업 단위는 꼭 질의어 한문장이 아니라 여러개의 질의어들의 집합일 수도 있다.

트랜잭션의 특징  
트랜잭션의 특징은 4가지가 존재한다.

- 원자성 (Atomicity)
- 일관성 (Consistency)
- 독립성 (Isolation)
- 지속성 (Durability)

트랜잭션의 Commit, Rollback
Commit : 하나의 트랜잭션이 성공적으로 끝났고 DB가 일관성있는 상태가 되었을 때 하나의 트랜잭션이 끝났다는 것을 알려주는 연산이다.
Rollback : 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진경우 트랜잭션을 처음부터 다시 시작하거나 트랜잭션의 부분적으로만 연산된 결과를 다시 취소하는 연산이다.

## Entity, DTO, VO

Entity(ORM)

1. Entity는 실제 DB 테이블과 매핑되는 핵심 클래스이다.
2. 이를 기준으로 테이블이 생성되고 스키마가 변경된다.
3. 따라서, 절대로 Entity를 요청이나 응답값을 전달하는 클래스로 사용해서는 안된다.
4. Entity는 id로 구분된다. 그리고 비즈니스 로직을 포함할 수 있다.
5. Entity는 DTO처럼 setter를 가지는 경우 가변 객체로 활용할 수 있다.

DTO(Data Transfer Object)

1. 데이터 유효성 체크, 데이터를 전달하기 위한 객체이다.
2. 계층간 데이터를 주고 받을 때, 데이터를 담아서 전달하는 바구니로 여러 레이어 사이에서 DTO를 사용할 수 있지만, 주로 View와 Controller 사이에서 데이터를 주고 받을 때 활용한다.
3. DTO는 getter / setter 메소드를 포함한다. 이 외의 비즈니스 로직은 포함하지 않는다.
4. setter를 가지는 경우 가변 객체로 활용할 수 있다.
5. 불변 객체로 만들면 데이터를 전달하는 과정에서 데이터가 변조되지 않음을 보장할 수 있다.

VO(Value Object)

1. VO는 값 자체를 표현하는 객체이다.
2. VO는 객체들의 주소가 달라도 값이 같으면 동일한 것으로 여긴다.
3. 예를 들어 고유번호가 서로 다르지만 값은 같은 객체 2개(예. 같은 값, 100을 가진 객체 x와 y)가 있다고 하면 둘은 고유번호(주소)는 다르지만 100은 동일하다.

| 분류   | 정의                       | 변경여부            | 로직 포함여부          |
| ------ | -------------------------- | ------------------- | ---------------------- |
| DTO    | 레이어간 데이터 전송용     | 가변 또는 불변 객체 | 로직을 포함할 수 없다. |
| VO     | 객체 값 표현용             | 불변 객체           | 로직을 포함할 수 있다. |
| Entity | 객체 DB 테이블 매핑용 객체 | 가변 또는 불변 객체 | 로직을 포함할 수 있다. |
