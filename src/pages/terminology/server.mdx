# 서버 용어

## 가상머신

1. 물리적 컴퓨터의 디지털 버전으로 가상 머신 소프트웨어는 프로그램 및 운영체제를 실행하고, 데이터를 저장하고, 네트워크에 연결하는 등 기타 컴퓨팅 기능을 수행할 수 있는 것을 말한다.
2. 컴퓨터상에 가상으로 컴퓨터를 구동시키는 것으로 물리적인 하드웨어를 가상화하여, 하나의 물리적 하드웨어 상에서 여러 컴퓨터가 구동되는 것처럼 에뮬레이션 하는 것을 칭하는 용어이다.
3. 에뮬레이션(Emulation)이란 한 컴퓨터가 다른 컴퓨터처럼 똑같이 작동하도록 소프트웨어나 마이크로 프로그래밍을 사용하는 기법이다.

## 가상화

1. 일반적으로 가상화는 컴퓨터에서 컴퓨터 리소스의 추상화를 일컫는 광범위한 용어로 물리적인 컴퓨터 리소스의 특징을 다른 시스템, 응용 프로그램, 최종 사용자들이 리소스와 상호 작용하는 방식으로부터 감추는 기술로 정의된다.
2. 물리적인 리소스들을 사용자에게 하나로 보이게 하거나, 하나의 물리적인 리소스를 여러 개로 보이게 하는 기술로 대부분의 서버는 용량의 20% 정도만을 사용하는데, 가상화를 통해 서버의 가동률을 60% ~ 70% 이상으로 올릴 수 있다.

## 컴퓨터 가상화

1. 가상화 기술요소로서 물리적으로 컴퓨터 리소스를 가상화하여 논리적 단위로 리소스를 활용할 수 있도록 하는 기술이다.
2. 가상화하는 컴퓨터 리소스로는 서버, 하드웨어(저장공간 - storage), 데스크탑, 네트워크 등이 있다.

## 분산 처리 기술

1. 여러대의 컴퓨터 계산 및 저장능력을 이용하여 커다란 계산문제나 대용량의 데이터를 처리하고 저장하는 기술이다.
2. 대량의 데이터를 처리해야하는 빅데이터에서 분산 처리 기술이 중요하게 사용된다.

## 네트워크 가상화

1. 물리적으로 떨어져있는 다양한 장비들을 연결하기 위한 수단으로 중계장치(라우터, 스위치 등)의 가상화를 통한 가상 네트워크(virtual network)를 지원하는 기술이다.
2. 네트워크 가상화의 예로는 가상 LAN(VLAN - Virtual Local Area Network)이 있고 물리적 위치와 상관없이 네트워크 디바이스를 단일 그룹으로 결합하는 소프트웨어로 생성된 LAN의 하위 섹션이다.
3. 실제로는 물리적위치가 떨어져 있더라도 논리적으로 네트워크를 단일 그룹으로 연결하여 LAN처럼 사용하는 것이다.

## 서버리스(serverless)

Red Hat 공식문서에서 서버리스(serverless)란 개발자가 서버를 관리할 필요 없이 애플리케이션을 빌드하고 실행할 수 있도록 하는 클라우드 개발모델이라고 서술되어있다.

즉 서버리스란?

1. 개발자가 애플리케이션을 구현함에 있어 서버를 고려하지 않아도 된다.
2. 구현뿐만 아니라 서버를 관리하지 않아도 된다는 것이다.
3. 서버가 없어진게 아니라 호스팅 플랫폼 (vercel, netlify, heroku 등) 에서 서버를 대신 관리해준다.
4. 클라우드에 있는 서버에서 개발한 소스코드를 대신 돌려준다.

개발자가 서버를 관리한다면?

1. 앱사용 / 트래픽 관리
2. 소프트웨어 관리
3. 서버 모니터링
4. 스케일링 (scale-up, scale-out, scale-down, scale-in 등)
5. 서버를 항상 운영
6. 비용적인 측면

위와 같은 사항들을 고려해야 한다.

서버리스를 사용한다면?

1. HTTP GET/products 라는 Resstful API를 실행하는 람다함수 f(x)가 있다.
2. f(x)라는 함수를 언제 실행하면 되는지만 호스팅 플랫폼에 있는 클라우드 서버에 알려준다.
3. 호스팅 플랫폼 사용한 CPU/Memory시간 만큼 비용을 청구한다.
4. 즉 비용적인 측면만 고려하면 된다.

장점

1. 개발자가 서버를 구현함에 있어 자유롭다.
2. 개발자가 서버를 관리함에 있어 고려해야 할 점을 고려하지 않아도 된다.
3. 확장이 쉽다.
4. 사용한 만큼 비용이 측정된다.

단점

1. Cold Start
   - 함수가 실행되어 클라우드상에 요청이 가면 Code를 다운로드하고 시작하는 개발환경을 구축하는 과정이 생긴다.
   - 위 이유 때문에 처음 시작하는데 시간이 오래 걸린다.
   - 위 과정을 Cold Start Duration라고 한다.
2. Resource limitation
   - 람다함수로 등록할 수 있는 함수의 메모리 사이즈(128MB)가 정해져있다.
   - 함수가 시작하고 끝날때까지 특정 시간(15minutes)이 초과되면 timeout이 발생한다.
3. No State
   - 상태가 없는, 독립적/개별적인 함수로 실행되어야 한다.
   - 함수 내부에서 전역데이터를 참조하거나 상태를 가질 수 없다.
   - 함수 내부에서 데이터베이스에서 접근해서 데이터를 읽고 써야한다. (Restful API)
4. 자체 서버를 실행하지 않거나 자체 서버측 로직을 제어하지 않는 데 따른 단점이 따른다.
   - 자체 서버가 아니고 서버측 로직을 제어할 수 없기때문에 유연성이 떨어진다.
   - 호스팅 플랫폼에 심하게 의존하게 된다는 단점이 있다.
5. 서버리스 기능이 최종 사용자와 거리에 따른 거리 지연이 생긴다.

## 스케일 업, 스케일 아웃, 스케일 다운, 스케일 인

## 스케일 업 (Scale-up)

1. 성능이나 용량 증강을 목적으로 하나의 서버에 디스크를 추가하거나 CPU나 메모리를 업그레이드시키는 것을 말한다.
2. 하나의 서버의 능력을 증강하기 때문에 수직 스케일링(vertical scaling)이라고도 한다.
3. 즉, 기존의 하드웨어를 보다 높은 사양으로 업그레이드하는 것을 말한다.

## 스케일 아웃 (Scale-out)

1. 기존의 서버와 같은 사양 또는 비슷한 사양의 서버 대수를 증가시키는 방법으로 처리 능력을 향샹시키는 것을 말한다.
2. 스케일 아웃 방식을 "수평 스케일"이라고 부르기도 하고, 확장이 스케일 업보다는 다소 유연하다.
3. 1의 처리 능력을 가진 서버에 동일한 서버 4대를 더 추가하여, 총 5의 처리 능력을 만드는 것이다.
4. 서버가 여러 대가 되기 때문에 각 서버에 걸리는 부하를 균등하게 해주는 ‘로드밸런싱’이 필수적으로 동반되어야 한다.

- 로드 밸런싱: 한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리한다.

## 스케일 업과 스케일 아웃은 왜 생겼을까?

1. 소프트웨어 서비스가 하나 있었고 해당 서버가 감당가능한 사용자는 100명이라고 하자.
2. 사용자가 100명이 넘어갔고 그에 따라 서버에 부하(부담)이 가게 되었다.
3. 이를 해결하기위해 서버 컴퓨터의 성능(질)을 올려보자라고 해서 나온 개념이 Scale-up이다.
4. 그렇게 서버에 문제가 생길 때마다 서버 컴퓨터의 성능을 올려 서버는 1000명의 사용자를 감당가능하게 되었다.
5. 그런데 더 이상 서버 컴퓨터의 성능을 기술적으로 올릴 수 없었다. (소켓의 수, 하드웨어의 기술적 문제 등)
6. 이를 해결하기위해 서버 컴퓨터의 양을 늘려 여러 대의 서버 컴퓨터가 나누어 고객을 감당하자해서 나온 개념이 Scale-out이다.

## 스케일 업 (Scale-up) 장, 단점

장점

1. 추가적인 네트워크 연결 없이 용량을 증강할 수 있다.
2. 추가되는 용량이나 업그레이드 비용만 부가되기에 비용적인 증강이 스케일아웃에 비해 낮고 설계가 쉽다.
3. 필요 장비와 전력 소모를 어느 정도 아낄 수 있고 인프라 비용이 추가로 발생하지 않는다.
4. 서버를 추가하는 방법이 아니기 때문에 여러대의 서버를 두는 것보다 데이터 정합성 이슈(데이터가 일관되지 않는 문제)에서 자유롭다.

단점

1. 하드웨어적 한계가 있다.
   - 스케일 업을 할수록 기존 하드웨어의 냉각, 공간, 전력공급 등의 문제가 발생할 수 있고, 하드웨어 허용 범위 내에서만 확장이 가능하기 때문에 그 이상으로 업그레이드를 하고자 한다면 한계가 있다.
   - 스케일 업을 하는 방법은 새로운 장비로 교체하는 방법밖에 없고 그 또한 성능이 좋지 않다면 의미가 없다.
   - 스케일 업의 일정 수준을 넘어가는 순간, 성능 증가 폭이 미미해지는 한계가 있다.
2. 서버 한 대에 모든 부하가 집중되므로 장애 시 서버가 복구될 때까지 서비스를 중단해야 하는 상황이 발생한다.

- 한 대의 서버에서 모든 데이터를 처리하므로 데이터 갱신이 빈번하게 일어나는 데이터베이스 서버에 적합한 방식이다.

## 스케일 아웃 (Scale-out) 장, 단점

장점

1. 서버 한 대가 장애로 다운되더라도 다른 서버로 서비스 제공이 가능하다는 장점이 있다.
2. 용량, 성능 확장에 한계가 없다. 하드웨어를 변경하는 것이 아닌 비슷한 성능의 서버를 여러 대 두는 방법이기 때문에, 확장이 무제한 가능하다.
3. 즉, 단일 서버에 작업이 쌓여서 멈춰있는 병목현상을 줄일 수 있다.

단점

1. 여러 대의 서버로 돌아가기 때문에 데이터 정합성 이슈(데이터가 일관되지 않는 문제)가 생길 수 있다.
2. 모든 서버에서 데이터 일관성을 유지해야하기 때문에 설계 및 관리가 복잡하다.
3. 세션, 웹 이미지 등 서버에 저장되는 데이터를 어떤식으로 공유해야할지에 대한 기술적인 한계가 있다.
4. 병렬 컴퓨팅 환경을 구성, 유지하려면, 로드 밸런싱에 대한 높은 이해도가 요구된다.
   - 병렬 컴퓨팅 환경: 여러 개의 프로세서를 통해 하나의 프로그램을 처리하는 환경이다.

- 모든 서버가 동일한 데이터를 가지고 있어야 하므로, 데이터 변화가 적은 웹서버에 적당하다.

네트워크 서버 설계 및 소프트 웨어 변경 비용이 더 클 수 있기 때문에 모든 서비스에 적합한 방식은 아니고 클라우드 환경 및 대규모 서비스환경에서 권장되는 방법이다.

## 스케일 다운 (Scale-down), 스케일 인 (Scale-in)이란?

스케일 다운 (Scale-down)

1. 스케일 업의 반대 개념이다.
2. 성능이나 용량 감소를 목적으로 하나의 서버에 디스크를 추출하거나 CPU나 메모리를 다운그레이드하는 것을 말한다.
3. 즉, 기존의 하드웨어를 보다 낮은 사양으로 다운그레이드하는 것을 말한다.

스케일 인 (Scale-in):

1. 스케일 아웃의 반대 개념이다.
2. 서버의 대수를 줄이는 것이다.
3. 스케일 아웃과 스케일 인을 트래픽등에 따라 자동으로 결정되게 설정하는 것을 오토 스케일링(Auto-Scaling)이라 한다.

- 두 개념 모두 주로 쓰이는 개념은 아니고 자원에 비해 트래픽이 너무 낮을 때, 관리자가 볼 때 서버가 일하는거에 비해 너무 좋은 성능을 가지고 있어 노는 자원(잉여 자원)이 많다고 생각이 들어 성능을 낮추는 개념이다.
