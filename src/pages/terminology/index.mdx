# 소프트웨어 공학용어

## 동적 계획법(Dynamic Programming, DP), 분할 정복(Divide and Conquer)의 정의와 차이점

1. 분할 정복(Divide and Conquer)

- 정의: 상위 문제를 나눌 수 없을 때까지 분할하여 각 하위 문제를 풀고 다시 합병하여 상위 문제의 답을 얻는 방식의 알고리즘이다.

특징

- 하향식 접근법: 상위 문제의 답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식. 즉, 상위 문제의 답을 구하기 위해 이전에 수행해야 하는 절차를 수행하는 방식이다.(재귀함수로 구현)
- 문제를 쪼갤 때, 부분 문제의 중복이 없다.

예: 병합 정렬, 퀵 정렬 등

2. 동적 계획법(Dynamic Programming, DP)

- 정의: 하나의 큰 문제를 해결하기 위해, 큰 문제를 작은 문제들로 나누어 부분적으로 해결한 후 그로부터 파생된 값인 해를 이용하여 최종적으로 전체 문제를 해결하는 방식의 알고리즘이다.

특징

- 가장 최하위 문제의 해답을 구한 후, 이를 이용하여 상위 문제를 풀어나가는 방식인 상향식 접근법이다.
- 큰 문제를 작게 쪼개어 문제를 해결할 때 중복되는 부분이 발생한다면 사용한다.
- 동일한 연산에 대해서는 1번의 연산을 수행하여 저장하여 계산의 중복을 방지한다.
- 중복을 방지하여 전체적인 수행 및 연산시간을 절약하여 실행 속도를 빠르게 한다.
- 메모이제이션(memoization)을 사용한다.
- 메모이제이션, 타뷸레이션을 사용하지않은 경우의 시간 복잡도: O(n\*n)
- 메모이제이션을 사용할 경우 시간 복잡도: O(n)
- 타뷸레이션을 사용할 경우 시간 복잡도: O(1)

예: 피보나치 수열, 팩토리얼 등

3. 동적 계획법과 분할 정복의 공통점과 차이점

- 공통점: 큰 문제를 작게 쪼개어 가장 작은 단위로 분할하여 문제를 해결한다.
- 차이점
  - 동적 계획법: 부분 문제에 중복이 발생할 경우 상위문제 해결 시 재활용하는 memoization을 사용한다.
  - 분할 정복: 부분 문제에 중복이 존재하지 않아 memoization을 사용하지 않는다.
  - 부분 문제에 중복이 발생할 경우 동적 계획법을 사용하고 발생하지 않는 경우 분할 정복을 사용한다.

## 타뷸레이션(Tabulation), 메모이제이션(Memoization)의 정의와 차이점

1. 타뷸레이션(Tabulation)이란?

   - 동일한 계산을 반복해야 할 경우 한 번 계산한 결과를 메모리에 저장해 두었다가 재사용하여 중복 계산을 방지할 수 있게 하는 기법이다.
   - 중복 계산을 방지하여 전체 실행 속도를 빠르게 한다.
   - 앞으로 계산할 모든 값에 대해 저장하여 초기화 오버헤드가 크다.
   - 초기화 이후에 계산해둔 값을 사용할 때 더 이상의 계산이 필요하지 않다.
   - Table + ulation으로 테이블에 미리 값을 적어놓는다고 생각하자.

2. 메모이제이션(memoization)이란?
   - 동적 프로그래밍(DP: Dynamic Programing)의 핵심이 되는 기술이다.
   - 동일한 계산을 반복해야 할 경우 한 번 계산한 결과를 메모리에 저장해 두었다가 재사용하여 중복 계산을 방지할 수 있게 하는 기법이다.
   - 중복 계산을 방지하여 전체 실행 속도를 빠르게 한다.
   - 이론적인 용어라 코딩 테스트, 알고리즘에서만 사용하는 용어이고 실제 현장에서는 캐싱(caching)이라는 단어를 더 많이 사용한다.

- 예:
  - 피보나치 수열: f(n-1), f(n-2)의 값을 메모이제이션하여 f(n)을 계산한다.
  - 팩토리얼을: f(n-1), f(n-2) .... 1의 값을 메모이제이션하여 f(n)을 계산한다.

3. 타뷸레이션과 메모이제이션의 차이점
   1. 메모이제이션과 비슷하지만, 값을 미리 계산해둔다는 차이점이 있다.
   2. 메모이제이션 결과가 필요해질 때 계산한다.(Lazy-Evaluation)
   - 필요한 값의 요청이 들어올 때 이전에 계산해둔 값이 있다면 그 값을 사용하고 없다면 새로 계산한다.
   - memoization을 활용하여 값을 계산할 경우 시간 복잡도는 O(n)이다.
   3. 타뷸레이션은 필요하지 않은 값도 미리 계산해둔다(Eager-Evaluation)는 차이가 있다.
   - 이전에 계산해둔 값이 있다면 그 값을 사용하고 없다면 새로 계산하는 방식으로 초기화할 때 범위에 해당하는 모든 값을 계산한다.
   - 초기화 오버헤드가 있지만 일단 계산해둔 값은 시간복잡도가 상수 시간(O(1))이 된다.

## 재귀(recursion) 및 재귀함수(recursive function), 팩토리얼을 구하는 함수 예제코드

1. 재귀
   - 자기자신을 호출한다는 말로 자기자신을 반복해서 돌아간다라는 의미를 가지고 있다.
2. 재귀함수

   - 재귀를 하는 함수로 정의 단계에서 자신을 재참조하는 함수를 뜻한다.

3. 재귀함수의 예시로 팩토리얼을 구하는 예제코드이다.

```js
const factorial = function (number) {
  if (number > 0) {
    return number * factorial(number - 1);
  } else {
    return 1;
  }
};

console.log(factorial(10));
```

- factorial 함수는 재귀함수로 factorial함수에서 factorial 함수를 또 호출한다. (자기 자신을 호출하는 것이다)
- 인자만 함수 내부에서 n에서 n-1로 바뀌게 된다.
- factorial(3)을 호출하면 내부적으로는 3 \* factorial(2)가 호출된다.
- factorial(2)는 2 _ factorial(1)을 호출하고 factorial(1)은 1 _ factorial(0)을 호출한다.
- factorial(0)==1이기때문에 최종적으로 결과는 3 _ 2 _ 1 \* 1 = 6이 된다.
- 위 3~5의 과정과 같이 factorial(n)의 값을 재귀적으로 계산하여 반환한다.

4. 결론
   1. 재귀적으로 푸는 것은 분할 정복 알고리즘(Divide and Conquer Algorithm) 중의 하나이다.
   - 어떤 문제를 한 번에 풀기 힘들 때, 작은 조각으로 쪼개어 푸는 것을 분할 정복 알고리즘라고 한다.
   2. 재귀를 사용하는 것은 컴퓨터에게는 많은 부담을 주지만, 개발자의 가독성을 높혀준다.
   3. 반복문에 비해 메모리를 많이 차지하기 때문에 성능을 중시한다면 재귀를 쓰지 않는 게 좋다.
   4. 재귀는 분할정복 알고리즘, DP 등에서 사용하여 DP를 사용할 때 재귀의 반환값이 보통 메모이제이션된다.

## 에라토스테네스의 체란?

1. 수학에서 에라토스테네스의 체는 고대 그리스에서 에라토스테네스가 발견한 소수를 찾는 방법이다.
2. 소수를 찾는 알고리즘 중에 하나로 2부터 찾고자하는 숫자의 범위 n의 값이 크면 클수록 효과적이다.
3. 알고리즘은 아래 사진과 같다.

![에라토스테네스의 체](/eratos.gif)

- 알고리즘
  1. 2부터 소수를 구하고자 하는 모든 수를 나열한다. 그림에서 회색 사각형으로 다른 수들이 여기에 해당한다.
  2. 2는 소수이므로 오른쪽 Prime numbers에 2를 써준다.
  3. 2를 제외한 모든 2의 배수를 지운다.
  4. 3은 소수이므로 오른쪽 Prime numbers에 3을 써준다.
  5. 3을 제외한 모든 3의 배수를 지운다.
  6. 5는 소수이므로 오른쪽 Prime numbers에 5를 써준다.
  7. 5를 제외한 모든 5의 배수를 지운다.
  8. 7은 소수이므로 오른쪽 Prime numbers에 7을 써준다.
  9. 7을 제외한 모든 7의 배수를 지운다.
  10. 위 과정을 구하고자하는 i를 2부터 i\*i가 n보다 작거나 같을때 까지만 수행해주면 된다.

예제코드

```js
let primeNumber = [];
primeNumber[0] = false;
primeNumber[1] = false;

const n = 120;
for (let i = 2; i <= n; i++) primeNumber[i] = true;

for (let i = 2; i * i <= n; i++) {
  if (primeNumber[i]) {
    for (let j = i * i; j <= n; j += i) {
      primeNumber[j] = false;
    }
  }
}

for (let i = 1; i <= n; i++) if (primeNumber[i]) console.log(i);
```

결과값으로 위 사진과 같이 소수들이 출력되는 것을 확인할 수 있다.

- outer 반복문에서 i\*i까지만 확인하는 이유는 아래와 같다.

### 에라토스테네스의 체에서 소수 판정 시 제곱근 까지만 확인하면 되는 이유

n이하의 모든 소수를 구하려고할 때 효율적으로 구하기 위해 n의 제곱근까지만 확인한다.

아래 예시를 보자.

1. n이하의 모든 소수를 구하고자할 때 n은 x와 y에 대해 n = x\*y이다. (x와 y는 자연수이다.)
2. n = m\*m이다. (m이 n의 제곱근이다.)
3. n = x*y이고 n = m*m이므로 x*y = m*m이다.

이 상태에서 x와 y가 자연수인 경우는 아래 3가지 경우이다.

1. x = y = m일 경우
2. x < m, y > m일 경우
3. x > m, y < m일 경우

결론

1. x와 y가 자연수가 되려면 위 세가지 경우 중 하나의 경우여야 한다.
2. x와 y의 최소값은 m보다 작거나 같아야한다. `(min(x,y) <= m)`
3. n의 모든 약수에 해당하는 자연수 x와 y는 x=y=m을 제외하고는 x와 y중 하나는 무조건 m보다 작아야 한다.
4. 결과적으로 m까지만 조사한다면 n이 소수인지 확인할 수 있다.

추가적으로 n보다 작은 모든 수에 대해 n의 제곱근으로 소수 판정 또한 가능하다.

1. n보다 작은 수 중에 가장 큰 수인 n-1에 대하여 n의 제곱근이 n-1의 제곱근보다 무조건 크다.
2. 위와 같이 n보다 작은 모든 수의 제곱근은 n의 제곱근보다 작으므로 n뿐만아니라 n보다 작은 모든 값에 대해 소수 판정이 가능하다.
